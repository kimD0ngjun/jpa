# 커스텀 객체 풀 아이디어

## 1. 계기

문자열은 리터럴을 통해 메모리 최적화를 한다. 이는, 동일 내용을 가진 문자열 객체를 굳이 새롭게 생성하지 않고 이전 값 주소를 똑같이 참조하게 하는 것이다. 어차피 객체 해시코드, 주소 등이 달라져도 내부 내용만 같으면 사용자는 쓰기 편할 테니

뭔가 이 아이디어를 JPA의 영속성 컨텍스트에서 활용할 수 있지 않을까 싶었다. 단일 트랜잭션 내에서는 영속성 컨텍스트의 캐싱을 통해 동일 엔티티를 계속 사용하게 된다. 하지만 다음 트랜잭션은 새로운 영속성 컨텍스트가 생겨나기 떄문에 새로운 객체를 쓰게 된다. 이 과정에서 이전의 트랜잭션 때 생성된 객체가 빠르게 지워지리라는 보장이 없다. 가비지 컬렉터를 개발자가 제어할 수 없으므로.

그래서 문자열 풀처럼 커스텀 객체 풀을 활용해 다음 트랜잭션에서도 이전 트랜잭션 때 조회한 엔티티 객체 주소를 다시 재사용할 수 있는 방법을 구현(까진 못해도 아이디어 구상)해볼까 생각 중.

## 2. How

일단 영속성 컨텍스트와 트랜잭션을 깊게 공부해야 하지 않을까

나는 여기서 이런 문제점을 확인했어. 문제 상황은, 두 번의 컨트롤러 호출(두 번 버튼 클릭)이라 생각해보자

1. 분명 사용자는 동일한 결과를 보게 된다
2. 그럼에도 리소스 중복 낭비가 생간다(영속성 컨텍스트 또 생성 + 똑같은 내용을 담은 객체 여러 개 생성 + hibernate가 똑같은 쿼리 날리게 됨)

그래서 중복을 최대한 배제하려고 문자열 리터럴 풀 아이디어에 기반해 해결책을 생각한 거야

그렇게 나온 아이디어가
1. 조회돼서 할당되는 객체 엔티티 인스턴스를 기존 트랜잭션에서 썼던 걸 또 쓴다
2. 기존 트랜잭션에 썼던 영속성 컨텍스트의 생명을 죽이지 앟고 다음 트랜잭션에 잇는다(사실 얘는 현실성이 낮을 것 같음)
3. 아예 영속성 컨텍스트의 단계로 넘어가기 전에 DTO 등으로 캐싱된 것을 다시 조회해오게 한다

그렇다면 1번을 기준으로 조금 더 깊게 생각을 해보자 

내가 알고 있는 조회 작업에 대한 트랜잭션의 흐름은 다음과 같아

1. 레포지토리에서 값을 가지고 옴
2. 영속성 컨텍스트에 그 객체가 저장됨
3. 해당 객체를 통해 조회 작업 마무리
4. 트랜잭션 종료

여기서 내가 막고 싶은 것은 아예 1번부터야. 즉 기존의 같은 작업을 또 반복한다면 굳이 hibernate가 쿼리를 날리는 단계니, 영속성 컨텍스트가 생성되는 단계니 등을 굳이 반복할 필요가 없는 거지.
저 1번조차도 나아가지 않는 것을 막기 위한 흐름을 자바 코드로 제어할 수 있을까? 아니 애초에 내가 알고 있는 순서가 저 1~4번이 맞나?

